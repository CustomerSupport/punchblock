#!/usr/bin/env ruby
$:.push File.join(File.dirname(__FILE__), '..', 'lib')
require 'rubygems'
require 'bundler/setup'
require 'punchblock'
require 'pry'
require 'logger'

Thread.abort_on_exception = true

options = {}
options[:username] = ARGV[0] || 'usera@127.0.0.1'
options[:password] = ARGV[1] || '1'

options[:wire_logger] = Logger.new 'log/ozone-wire.log'
options[:wire_logger].level = Logger::DEBUG
options[:wire_logger].debug "Starting up..."
options[:transport_logger] = Logger.new 'log/ozone-transport.log'
options[:transport_logger].level = Logger::DEBUG
options[:transport_logger].debug "Starting up..."

protocol = Punchblock::Protocol::Ozone.new options

protocol_thread = protocol.run

CALL_QUEUES = {}
INFO_EVENT_QUEUE = Queue.new

# Block on waiting for the XMPP to connect, then show when we are connected
puts protocol.event_queue.pop
puts "Waiting for a call..."

### DISPATCHER THREAD
# This thread multiplexes the event stream from the underlying connection handler and routes them
# to the correct queue for each call.  It also starts a call handler, the run_call method) after creating
# the queue.
Thread.new do
  loop do
    event = protocol.event_queue.pop
    puts "#{event.class} event for call: #{event.call_id}"
    case event
    when Punchblock::Call
      raise "Duplicate call ID for #{event.call_id}" if CALL_QUEUES.has_key?(event.call_id)
      CALL_QUEUES[event.call_id] = Queue.new
      CALL_QUEUES[event.call_id].push event
      run_call protocol, event
    when protocol.class::Event::Info
      INFO_EVENT_QUEUE.push event
    when protocol.class::Event::Complete, protocol.class::Event::End
      CALL_QUEUES[event.call_id].push event
    else
      puts "Unknown event: #{event.inspect}"
    end

  end
end

def run_call(protocol, call)
  ### CALL THREAD
  # One thread is spun up to handle each call.
  Thread.new do
    raise "Unknown call #{call.call_id}" unless CALL_QUEUES.has_key?(call.call_id)
    queue = CALL_QUEUES[call.call_id]
    call = queue.pop
    dsl = Punchblock::DSL.new protocol, call, queue

    puts "Incoming call to #{call.to} from #{call.headers[:from]} #{call}"
    dsl.pry

    # Clean up the queue.
    CALL_QUEUES[call.call_id] = nil
  end
end

protocol_thread.join
